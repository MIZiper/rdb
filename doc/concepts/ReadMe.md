# RDB开发概念

## 概念设计

### 基础功能

RDB的主要目标是存储各种类型的资源，能快速找到历史数据。

通过标签的方式，筛选来自一个项目的各种信息（纵向），或者筛选来自不同项目的同一类信息（横向）。
此外标签是结构化的，在筛选父标签时，带子标签的资源也能被选中。

除了数据存储外，还提供简单的工具对筛选结果进行快速的可视化与对比。

### 本质分析

不同的数据类型，其实就类似于每种数据是一个文件类型，有不同的程序打开。
本质上来说是“带标签的文档管理系统”，不过RDB是更简单的文件。

RDB只存储约定好结构的数据，为了实现数据结构化，带来的是表达能力的限制，RDB需要使用者了解数据的上下文环境。
文档本身也能存储信息，不过文档通常需要将各种信息整合，把来龙去脉解释清楚。

### 原始方案

每个RDB资源，主要包含元信息（如类型、标题、标签、时间等）以及数据体（文本、图片、表格、二进制数据等）。

在开始的设想中每个资源对应一个独立的文件，如此能简单的备份、删除。只要提供文件就能打开查看。
但是文件的顺序结构对于局部更新不是很方便，另外对于通用数据需要再造轮子（例如要将所有图片打包在一个文件中）。

## 资源模块

模块、资源类型、数据类型，差不多是同样的意思。
不过同一种资源类型，比如以图片形式储存的信息，可以是流程图，也可以是产品结构。
或者各人用于自己的目的，资源类型相同，但是要创建不同的模块，把上下文环境限定在某个范围内。

### 基础模块

- Generic

    提供一种宽泛的信息表达，不设置特定的表单结构。
    能够描述信息即可，可使用Markdown的形式。
    内容可能就一句话、一个数值，或者指向某个已经存在的文档。

- Mermaid流程图

    Mermaid图有不同的表现形式，可以用于宽泛的场景。
    如前所述，可以用相同的资源类型来定义不同的模块。
    例如定义一个模块来记录产品变化路径；定义一个模块来做产品结构分解。

- 数据表格

    经典的表格数据，列是不同的域或者数据来源，行是不同的对象或不同时间点的结果。
    能够对结果进行简单的展示或者交叉对比。

- 图片集

    提供简单的图片上传加备注功能，能够作为典型特征目录。

- Python Widget

    （其实我有点忘了为什么要这个功能，或者说这个设计不兼容当前的路线）

    在保障系统、数据安全的前提下，允许创建Python脚本去处理RDB资源文件，
    （为了安全考虑，可以将模块创建为容器，然后将数据传递映射给模块进行处理）。
    这有点类似于PowerBI的组件，不过PBI只会将统计性数据传给Python组件，而RDB可能是二进制数据。

    设计的原因大概是：
    假设资源类型是处理过的振动阶次数据，数据大小中等（大于简单的表格，小于原始高采样的时间信号），自定义二进制形式存储。
    需要对这些数据进行读取、操作、结果呈现等。

### 定制模块

- 产品信息

    很简单的表单，记录产品的主要参数，方便随时查询。

- 统计性数据

    和前面的“数据表格”是一样的。
    额外列出，此中难点是：在不同的项目中，“域”不是一定相同的。
    典型场景是传感器的命名与数量在不同项目中是不一样的；或者某些项目中有额外的输入参数。
    做跨项目的对比时，要如何处理这种例外。
    如果预定义好共有“域”，后续会有不完备的情况。而如果包含所有的“域”，则会是个稀疏表格。

- 振动噪声

**更加定制场景**

只是随便写写，描述下可能的场景。
RDB的场景就是各种各样的数据，用各自结构化的方式，存储在一起。
要求用户在标签的限定下，知道数据所代表的含义。

- 产品可运行空间

    通过边界点定义产品在组合参数下能够运行的空间。

- 运行参数定义

    比如需要定义测试步骤，各种输入参数的变化。

RDB不能替代文档。
RDB的目标除了前述的功能，还有一个衍生目标。
多数情况下，我们发布的是文档，文档可能描述了各种信息，包含数据**的信息**，但是是经过渲染后的图片或者表格。
而RDB如果有发布功能，那么它发布的就是数据本身，可以直接被下游使用的数据。

### 模块内容

- 前端
- 后端
- 数据库
- 对比

### 其它

**无编辑界面模块**

对于简单数据类型的模块，输入通过网页前端就可以完成。
而有些复杂的、数据量大的模块，则通过向模块后端API发起数据推送来交互。

没有数据编辑前端，但还是有数据展示前端。
数据展示/使用也可以通过API在其它工具中来完成。

## 数据交换

在模块的 前端编辑呈现、前后端沟通、后端提供API服务 中，
最重要的就是数据结构与数据交换。

- 实际存储

    最终持久化数据是存在数据库中，还是有自己定义的结构。
    是序列化完的JSON字符串，原始文本，还是二进制的结构数据。

- 后端对象

    后端能够将持久化的数据还原为对象，以便进行后续对象操作。
    模型内部可能有自己的复杂计算，而向外时只显示为稳定的、简单的、有效的结构。

- 传输结构

    通过JSON的方式，为前端或者其它的客户端提供后处理所需要的结构化数据。
    客户端需要通过结构知道预期如何，自己该怎么处理。

    需要用Swagger编写API文档。

- 前端对象

    前端是否要后端传输进来的数据也创建为对象以便于操作。

- 前端展示

    将信息渲染展示出来。

简单的情况下，前后端基本没有结构差异。